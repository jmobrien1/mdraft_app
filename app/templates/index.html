{% extends "base.html" %}
{% block title %}mdraft â€” upload & convert{% endblock %}
{% block content %}
  <div class="card">
    <h2>Upload to convert</h2>
    <p class="hint">Drop a file below or click to select. You'll get Markdown back. Async mode will queue and process via the worker.</p>
    <p class="hint">Optional: add <code>callback_url</code> to your API request to receive a POST when the conversion finishes. Verify with the <code>X-MDraft-Signature</code> header (HMAC SHA-256).</p>

    <form id="form" class="section">
      <div id="drop" class="drop">
        <input id="file" type="file" name="file" style="display:none" required />
        <div>ðŸ“„ Drag & drop file here or <button class="btn secondary" type="button" id="pick">Choose file</button></div>
        <div id="chosen" class="hint" style="margin-top:6px;"></div>
      </div>
      <div id="estimate-line" style="margin-top:8px; font-size:0.9rem; color:#666;"></div>
      <div class="row" style="margin-top:12px;">
        <button id="btn" class="btn" type="submit">Convert</button>
        <span id="status" class="hint">Idle</span>
      </div>
      <div class="row" style="margin-top:8px;">
        <input id="apiKey" class="input" placeholder="API key (optional)"/>
        <button class="btn secondary" id="saveKey" type="button">Save key</button>
        <span id="keyStatus" class="hint"></span>
      </div>
    </form>
  </div>

  <div class="section card">
    <h2>Result</h2>
    <textarea id="out" class="ta mono" placeholder="Markdown will appear here..." readonly></textarea>
    <div class="row" style="margin-top:8px;">
      <button class="btn secondary" id="copyMd" type="button">Copy Markdown</button>
      <button class="btn secondary" id="dlMd" type="button">Download .md</button>
    </div>
  </div>

  <div class="section card">
    <div class="row" style="justify-content:space-between;">
      <h2>Recent conversions</h2>
      <span class="hint">latest 10</span>
    </div>
    <div id="recent">
      <div class="skel" style="width:70%"></div>
      <div class="skel" style="width:40%;margin-top:8px"></div>
      <div class="skel" style="width:55%;margin-top:8px"></div>
    </div>
  </div>
{% endblock %}

{% block scripts %}
<script type="module">
  import {toast,copy,fmtDate,dragAndDrop} from "/static/app.js";
  const form = document.getElementById('form');
  const file = document.getElementById('file');
  const btn = document.getElementById('btn');
  const out = document.getElementById('out');
  const statusEl = document.getElementById('status');
  const pick = document.getElementById('pick');
  const drop = document.getElementById('drop');
  const chosen = document.getElementById('chosen');

  const apiKeyInput = document.getElementById('apiKey');
  const keyStatus = document.getElementById('keyStatus');
  const savedKey = localStorage.getItem('apiKey') || '';
  if (savedKey) { apiKeyInput.value = savedKey; keyStatus.textContent = 'Using saved key'; }
  document.getElementById('saveKey').onclick = ()=>{
    localStorage.setItem('apiKey', apiKeyInput.value.trim());
    keyStatus.textContent = apiKeyInput.value.trim() ? 'Key saved' : 'Key cleared';
  };

  pick.addEventListener('click', ()=> file.click());
  dragAndDrop(file, drop);
  drop.addEventListener('click', (e)=>{ if(e.target===drop) file.click(); });
  file.addEventListener('change', ()=> chosen.textContent = file.files[0] ? file.files[0].name : "");

  form.addEventListener('submit', async (e)=>{
    e.preventDefault();
    if (!file.files.length) return;
    const fd = new FormData();
    fd.append('file', file.files[0]);
    btn.disabled = true; statusEl.textContent = 'Uploadingâ€¦';

    try{
      const headers = {};
      const k = (localStorage.getItem('apiKey') || '').trim();
      if (k) headers['X-API-Key'] = k;
      const res = await fetch('/api/convert', { method: 'POST', body: fd, headers });
      const data = await res.json();
      if (res.status === 202 && data.status === "QUEUED"){
        statusEl.textContent = 'Queuedâ€¦';
        const poll = async ()=>{
          const r = await fetch(data.links.self);
          const j = await r.json();
          if (j.status === "COMPLETED"){
            statusEl.textContent = "Completed";
            const mres = await fetch(j.links.markdown);
            out.value = await mres.text();   // <-- always load markdown text
            toast("Done"); await (window.loadRecent && window.loadRecent());
          } else if (j.status === "FAILED"){
            statusEl.textContent = "Failed";
            out.value = j.error || "conversion failed";
            toast("Failed", 2000);
          } else {
            setTimeout(poll, 1200);
          }
        }; poll();
      } else if (res.ok) {
        statusEl.textContent = 'Done';
        if (data.markdown) {
          out.value = data.markdown;
        } else if (data.links && data.links.markdown) {
          const mres = await fetch(data.links.markdown);  // <-- fetch when only a link is returned
          out.value = await mres.text();
        } else {
          out.value = ""; // nothing? keep empty
        }
        toast("Done"); await (window.loadRecent && window.loadRecent());
      } else {
        statusEl.textContent = 'Error';
        out.value = JSON.stringify(data);
        toast("Error", 2000);
      }
    }catch(err){
      statusEl.textContent = 'Network error'; out.value = String(err); toast("Network error", 2000);
    }finally{
      btn.disabled = false; form.reset(); chosen.textContent="";
    }
  });

  document.getElementById('copyMd').onclick = ()=> navigator.clipboard.writeText(out.value||"");
  document.getElementById('dlMd').onclick = ()=>{
    const blob = new Blob([out.value||""], {type:"text/markdown"});
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='mdraft.md'; a.click(); URL.revokeObjectURL(url);
  };
</script>

<script>
// Load recent conversions (global so other scripts/HTML can call it)
window.loadRecent = async function loadRecent() {
  try {
    const res = await fetch('/api/conversions?limit=10', { headers: { 'Accept': 'application/json' }});
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if (!res.ok || !ct.includes('application/json')) {
      const _txt = await res.text();
      console.warn('recent conversions not JSON', res.status, ct);
      return;
    }
    const data = await res.json();
    // â¬‡ï¸ keep the existing DOM rendering for the recent list here, unchanged
    const el = document.getElementById('recent');
    el.innerHTML = '';
    (data.items||[]).forEach(item=>{
      const row = document.createElement('div'); row.className='item';
      const left = document.createElement('div');
      left.innerHTML = `<a class="link" href="${item.links.view||('/v/'+item.id)}" target="_blank">${item.filename}</a>
        <span class="badge">${item.status}</span>
        <span class="hint">${fmtDate(item.created_at)}</span>`;
      const right = document.createElement('div');
      const a1 = document.createElement('a'); a1.className='link'; a1.href=item.links.markdown; a1.textContent='Markdown'; a1.target='_blank';
      const a2 = document.createElement('a'); a2.className='link'; a2.href=item.links.view||('/v/'+item.id); a2.textContent='View'; a2.style.marginLeft='12px'; a2.target='_blank';
      const cp = document.createElement('button'); cp.className='btn secondary'; cp.style.marginLeft='12px'; cp.textContent='Copy link';
      cp.onclick=()=> copy(location.origin+(item.links.view||('/v/'+item.id)));
      const loadBtn = document.createElement('button');
      loadBtn.className = 'btn secondary';
      loadBtn.style.marginLeft = '12px';
      loadBtn.textContent = 'Load here';
      loadBtn.onclick = async ()=>{
        statusEl.textContent = 'Loadingâ€¦';
        const m = await fetch(item.links.markdown);
        out.value = await m.text();
        statusEl.textContent = 'Loaded';
      };
      right.append(a1,a2,cp,loadBtn);
      row.append(left,right); el.append(row);
    });
  } catch (e) {
    console.warn('recent conversions fetch failed', e);
  }
};
// Auto-run on DOM ready, but keep function callable globally too
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => window.loadRecent());
} else {
  window.loadRecent();
}

window.loadRecent && window.loadRecent();
;(function () {
  const chooseBtn = document.getElementById('choose') || document.querySelector('[data-choose]');
  const fileInput = document.getElementById('file');
  if (chooseBtn && fileInput) {
    chooseBtn.addEventListener('click', (e) => { e.preventDefault(); fileInput.click(); });
  }
})();
</script>

<script>
(function () {
  const input = document.getElementById('file');
  const line  = document.getElementById('estimate-line');
  if (!input || !line) return;
  input.addEventListener('change', async () => {
    if (!input.files || !input.files[0]) { line.textContent = ''; return; }
    const file = input.files[0];
    line.textContent = 'Estimatingâ€¦';
    try {
      const fd = new FormData();
      fd.append('file', file, file.name);
      const res = await fetch('/api/estimate', {
        method: 'POST',
        body: fd,
        headers: { 'Accept': 'application/json' },
        credentials: 'same-origin',
      });
      // Handle non-OK or non-JSON responses safely
      const ct = (res.headers.get('content-type') || '').toLowerCase();
      if (!res.ok || !ct.includes('application/json')) {
        const text = await res.text();
        console.warn('Estimate non-JSON or error', res.status, ct, text.slice(0,200));
        line.textContent = (res.status === 413) ? 'File too large for estimate.' : 'Estimate unavailable.';
        return;
      }
      const data = await res.json();
      if (!data || typeof data.pages !== 'number') { line.textContent = 'Estimate unavailable.'; return; }
      line.textContent = `Estimate: ~${data.pages} premium pages â†’ ~$${data.est_cost_usd} (not billed until run).`;
    } catch (err) {
      console.error('Estimate fetch failed', err);
      line.textContent = 'Estimate unavailable.';
    }
  });
})();
</script>
{% endblock %}
